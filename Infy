<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>






@Configuration
public class CorsConfiguration implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
            .allowedOrigins("*")
            .allowedMethods("GET", "POST", "PUT", "DELETE")
            .allowedHeaders("*");
    }
}







@Configuration
@EnableWebSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.cors().and().csrf().disable();
    }
}

























<!DOCTYPE html>
<html>

<head>
    <title>Graph Visualization</title>
    <style>
        /* CSS styles omitted for brevity */
    </style>
</head>

<body>
    <h1>Query Form</h1>
    <form id="messageForm">
        <label for="message">Enter your Query:</label>
        <input type="text" id="message" name="message" required>
        <button type="submit">Submit</button>
    </form>

    <div id="statusMessage"></div>
    <div id="visualization"></div>

    <script src="https://visjs.github.io/vis-network/standalone/umd/vis-network.min.js"></script>
    <script>
        // Load the WebAssembly module
        const wasmModule = fetch('Converter.wasm')
            .then(response => response.arrayBuffer())
            .then(buffer => WebAssembly.instantiate(buffer))
            .then(module => {
                // Store the instantiated module
                window.wasmModule = module;
                console.log('Wasm module loaded successfully');
            })
            .catch(error => {
                console.error('Failed to load Wasm module:', error);
            });

        // Create a web worker for base64 to JSON conversion
        const worker = new Worker('base64Worker.js');

        // Function to process the JSON data and create a vis.js visualization
        function createVisualization(jsonData) {
            const data = JSON.parse(jsonData);

            const nodes = data.nodes;
            const edges = data.edges;

            const dataset = new vis.DataSet(nodes);

            const options = {
                nodes: {
                    shape: 'circle',
                    color: '#4CAF50',
                    font: {
                        color: '#ffffff',
                    },
                },
                edges: {
                    color: '#848484',
                },
            };

            const container = document.getElementById('visualization');
            const network = new vis.Network(container, dataset, options);
        }

        // Function to handle web worker message
        function handleWorkerMessage(event) {
            const { jsonData } = event.data;
            createVisualization(jsonData);
            statusMessage.textContent = 'Query fetched successfully';
        }

        // Function to handle form submission
        function submitForm(event) {
            event.preventDefault();

            const messageInput = document.getElementById('message');
            const message = messageInput.value;

            const statusMessage = document.getElementById('statusMessage');
            statusMessage.textContent = 'Query is being fetched...';

            try {
                const response = await fetch('/executeQuery', {
                    method: 'POST',
                    body: JSON.stringify({ query: message }),
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to fetch query');
                }

                const data = await response.json();
                const base64String = data.base64String;

                // Post the base64 string to the web worker for conversion
                worker.postMessage(base64String);
            } catch (error) {
                statusMessage.textContent = 'Failed to fetch query';
                console.error('Error:', error);
            }
        }

        const form = document.getElementById('messageForm');
        form.addEventListener('submit', submitForm);

        // Listen for web worker messages
        worker.addEventListener('message', handleWorkerMessage);
    </script>
</body>

</html>








sdfvsdfsdfsdfsfsdfsdfsdfs








// base64Worker.js

// Function to convert base64 string to JSON using the loaded Wasm module
async function convertBase64ToJSON(base64String) {
    const module = await wasmModule;
    const convert = module.instance.exports.convert;
    const base64Ptr = module.instance.exports.__allocArray(module.instance.exports.Uint8Array_ID, base64String);
    const jsonPtr = convert(base64Ptr);
    const jsonString = module.instance.exports.__getString(jsonPtr);
    module.instance.exports.__free(base64Ptr);
    module.instance.exports.__free(jsonPtr);
    return jsonString;
}

// Listen for messages from the main thread
self.addEventListener('message', async event => {
    const { data: base64String } = event;
    const jsonData = await convertBase64ToJSON(base64String);
    self.postMessage({ jsonData });
});















csdfsdfsdfdsfsdfsdfsdfsd






<!DOCTYPE html>
<html>

<head>
    <title>Graph Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
            padding: 20px;
        }

        h1 {
            text-align: center;
            color: #333;
        }

        #messageForm {
            max-width: 400px;
            margin: 0 auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: #333;
        }

        input[type="text"] {
            width: 90%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        button[type="submit"] {
            background-color: #4CAF50;
            color: #fff;
            margin-top: 10px;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;

        }

        #statusMessage {
            text-align: center;
            margin-top: 20px;
            font-weight: bold;
            color: #333;
        }

        #visualization {
            height: 500px;
            margin-top: 20px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
    </style>
</head>

<body>
    <h1>Query Form</h1>
    <form id="messageForm">
        <label for="message">Enter your Query:</label>
        <input type="text" id="message" name="message" required>
        <button type="submit">Submit</button>
    </form>

    <div id="statusMessage"></div>
    <div id="visualization"></div>

    <script src="https://visjs.github.io/vis-network/standalone/umd/vis-network.min.js"></script>
    <script>
        // Load the WebAssembly module
        const wasmModule = fetch('Converter.wasm')
            .then(response => response.arrayBuffer())
            .then(buffer => WebAssembly.instantiate(buffer))
            .then(module => {
                // Store the instantiated module
                window.wasmModule = module;
                console.log('Wasm module loaded successfully');
            })
            .catch(error => {
                console.error('Failed to load Wasm module:', error);
            });

        // Function to convert base64 string using the loaded Wasm module
        async function convertBase64ToJSON(base64String) {
            const module = await wasmModule;
            const convert = module.instance.exports.convert;
            const base64Ptr = module.instance.exports.__allocArray(module.instance.exports.Uint8Array_ID, base64String);
            const jsonPtr = convert(base64Ptr);
            const jsonString = module.instance.exports.__getString(jsonPtr);
            module.instance.exports.__free(base64Ptr);
            module.instance.exports.__free(jsonPtr);
            return jsonString;
        }

        // Function to process the JSON data and create a vis.js visualization
        function createVisualization(jsonData) {
            const data = JSON.parse(jsonData);

            const nodes = data.nodes;
            const edges = data.edges;

            const dataset = new vis.DataSet(nodes);

            const options = {
                nodes: {
                    shape: 'circle',
                    color: '#4CAF50',
                    font: {
                        color: '#ffffff',
                    },
                },
                edges: {
                    color: '#848484',
                },
            };

            const container = document.getElementById('visualization');
            const network = new vis.Network(container, dataset, options);
        }

        // Function to handle form submission
        async function submitForm(event) {
            event.preventDefault();

            const messageInput = document.getElementById('message');
            const message = messageInput.value;

            const statusMessage = document.getElementById('statusMessage');
            statusMessage.textContent = 'Query is being fetched...';

            try {
                const response = await fetch('/executeQuery', {
                    method: 'POST',
                    body: JSON.stringify({ query: message }),
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to fetch query');
                }

                const data = await response.json();
                const base64String = data.base64String;

                const jsonResult = await convertBase64ToJSON(base64String);

                createVisualization(jsonResult);

                statusMessage.textContent = 'Query fetched successfully';
            } catch (error) {
                statusMessage.textContent = 'Failed to fetch query';
                console.error('Error:', error);
            }
        }

        const form = document.getElementById('messageForm');
        form.addEventListener('submit', submitForm);
    </script>
</body>

</html>
















{
  "nodes": [
    { "id": 1, "label": "Node 1" },
    { "id": 2, "label": "Node 2" },
    { "id": 3, "label": "Node 3" }
  ],
  "edges": [
    { "from": 1, "to": 2 },
    { "from": 2, "to": 3 },
    { "from": 3, "to": 1 }
  ]
}


















<!-- the code sets up an HTML form where users can enter a query. When the form is submitted, the query is sent to the
backend (not included in the provided code), which responds with a base64 string. The base64 string is then converted to
JSON using a WebAssembly module. The resulting JSON data is used to create a graph visualization using vis.js, which is
displayed in the "visualization" element on the page. -->
<!DOCTYPE html>
<html>

<head>
    <title>Graph Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
            padding: 20px;
        }

        h1 {
            text-align: center;
            color: #333;
        }

        #messageForm {
            max-width: 400px;
            margin: 0 auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: #333;
        }

        input[type="text"] {
            width: 95%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        button[type="submit"] {
            background-color: #4CAF50;
            color: #fff;
            margin-top: 10px;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;

        }

        #statusMessage {
            text-align: center;
            margin-top: 20px;
            font-weight: bold;
            color: #333;
        }

        #visualization {
            height: 500px;
            margin-top: 20px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
    </style>
</head>

<body>
    <h1>Query Form</h1>
    <form id="messageForm">
        <label for="message">Enter your Query:</label>
        <input type="text" id="message" name="message" required>
        <button type="submit">Submit</button>
    </form>

    <div id="statusMessage"></div>
    <div id="visualization"></div>

    <script src="https://visjs.github.io/vis-network/standalone/umd/vis-network.min.js"></script>
    <script>
        // Load the WebAssembly module
        const wasmModule = fetch('wasm_module.wasm')
            .then(response => response.arrayBuffer())
            .then(buffer => WebAssembly.instantiate(buffer))
            .then(module => {
                // Store the instantiated module
                window.wasmModule = module;
                console.log('Wasm module loaded successfully');
            })
            .catch(error => {
                console.error('Failed to load Wasm module:', error);
            });

        // Function to convert base64 string using the loaded Wasm module
        async function convertBase64ToJSON(base64String) {
            const module = await wasmModule;
            const convert = module.instance.exports.convert;
            const base64Ptr = module.instance.exports.__allocArray(module.instance.exports.Uint8Array_ID, base64String);
            const jsonPtr = convert(base64Ptr);
            const jsonString = module.instance.exports.__getString(jsonPtr);
            module.instance.exports.__free(base64Ptr);
            module.instance.exports.__free(jsonPtr);
            return jsonString;
        }

        // Function to process the JSON data and create a vis.js visualization
        function createVisualization(jsonData) {
            const data = JSON.parse(jsonData);

            const dataset = new vis.DataSet(data);

            const options = {
                nodes: {
                    shape: 'circle',
                    color: '#4CAF50',
                    font: {
                        color: '#ffffff',
                    },
                },
                edges: {
                    color: '#848484',
                },
            };

            const container = document.getElementById('visualization');
            const network = new vis.Network(container, dataset, options);
        }

        // Function to handle form submission
        async function submitForm(event) {
            event.preventDefault();

            const messageInput = document.getElementById('message');
            const message = messageInput.value;

            const statusMessage = document.getElementById('statusMessage');
            statusMessage.textContent = 'Query is being fetched...';

            try {
                const jsonResult = await convertBase64ToJSON(message);

                createVisualization(jsonResult);

                statusMessage.textContent = 'Query fetched successfully';
            } catch (error) {
                statusMessage.textContent = 'Failed to fetch query';
                console.error('Error:', error);
            }
        }

        const form = document.getElementById('messageForm');
        form.addEventListener('submit', submitForm);
    </script>
</body>

</html>


















44444444444444444444444
#the code that is used to send the query to the back end in json format:



<!DOCTYPE html>
<html>
<head>
  <title>Graph Visualization</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f5f5f5;
      padding: 20px;
    }

    h1 {
      text-align: center;
      color: #333;
    }

    #messageForm {
      max-width: 400px;
      margin: 0 auto;
      background-color: #fff;
      padding: 20px;
      border-radius: 5px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    label {
      display: block;
      margin-bottom: 10px;
      font-weight: bold;
      color: #333;
    }

    input[type="text"] {
      width: 100%;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    button[type="submit"] {
      background-color: #4CAF50;
      color: #fff;
	margin-top: 10px;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;

    }

    #statusMessage {
      text-align: center;
      margin-top: 20px;
      font-weight: bold;
      color: #333;
    }
  </style>
</head>
<body>
  <h1>Query Form</h1>
  <form id="messageForm">
    <label for="message">Enter your Query:</label>
    <input type="text" id="message" name="message" required>
    <button type="submit">Submit</button>
  </form>

  <div id="statusMessage"></div>

  <script>
    function submitForm(event) {
      event.preventDefault();

      const messageInput = document.getElementById('message');
      const message = messageInput.value;

      const data = {
        Query: message
      };

      const statusMessage = document.getElementById('statusMessage');
      statusMessage.textContent = 'Query is being fetched...';

      fetch('/executeQuery', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(data)
      })
      .then(response => {
        if (response.ok) {
          statusMessage.textContent = 'Query fetched successfully';
          // Handle the response from the backend if needed
          console.log('Data sent successfully');
        } else {
          statusMessage.textContent = 'Failed to fetch query';
          throw new Error('Request failed');
        }
      })
      .catch(error => {
        statusMessage.textContent = 'Failed to fetch query';
        console.error('Error:', error.message);
      });
    }

    const form = document.getElementById('messageForm');
    form.addEventListener('submit', submitForm);
  </script>
</body>
</html>












22222222222222222


#the code to send the received protobuf file to another backend endpoint and fetch a WebAssembly (Wasm) file in return:





<!DOCTYPE html>
<html>

<head>
    <title>Query Form</title>
    <style>
        /* ... CSS styles ... */
        body {
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
            padding: 20px;
        }

        h1 {
            text-align: center;
            color: #333;
        }

        #messageForm {
            max-width: 400px;
            margin: 0 auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: #333;
        }

        input[type="text"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        button[type="submit"] {
            background-color: #4CAF50;
            color: #fff;
            border: none;
margin-top: 10px;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
        }

        #statusMessage {
            text-align: center;
            margin-top: 20px;
            font-weight: bold;
            color: #333;
        }
    </style>
</head>

<body>
    <h1>Query Form</h1>
    <form id="messageForm">
        <label for="message">Enter your Query:</label>
        <input type="text" id="message" name="message" required>
        <button type="submit">Submit</button>
    </form>

    <div id="statusMessage"></div>

    <script>
        function submitForm(event) {
            event.preventDefault();

            const messageInput = document.getElementById('message');
            const message = messageInput.value;

            const data = {
                Query: message
            };

            const statusMessage = document.getElementById('statusMessage');
            statusMessage.textContent = 'Query is being fetched...';

            fetch('/executeQuery', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            })
                .then(response => {
                    if (response.ok) {
                        return response.blob(); // Retrieve the response body as a Blob
                    } else {
                        throw new Error('Request failed');
                    }
                })
                .then(blobData => {
                    statusMessage.textContent = 'Query fetched successfully. Sending protobuf file to backend...';
                    return fetch('/uploadProtobuf', {
                        method: 'POST',
                        body: blobData
                    });
                })
                .then(response => {
                    if (response.ok) {
                        return response.blob(); // Retrieve the response body as a Blob
                    } else {
                        throw new Error('Failed to upload protobuf file');
                    }
                })
                .then(wasmBlob => {
                    statusMessage.textContent = 'Protobuf file uploaded successfully. Fetching WebAssembly (Wasm) file...';
                    // Process the wasmBlob (Wasm file) as needed
                    // For example, you can save it or use it with vis.js for visualization
                    console.log('Wasm file received:', wasmBlob);
                })
                .catch(error => {
                    statusMessage.textContent = 'Error occurred during the process';
                    console.error('Error:', error.message);
                });
        }

        const form = document.getElementById('messageForm');
        form.addEventListener('submit', submitForm);
    </script>
</body>

</html>












55555555555555555555555






#the code that retrieves a protobuf file as the response:



<!DOCTYPE html>
<html>

<head>
    <title>Query Form</title>
    <style>
        /* ... CSS styles ... */
        body {
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
            padding: 20px;
        }

        h1 {
            text-align: center;
            color: #333;
        }

        #messageForm {
            max-width: 400px;
            margin: 0 auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: #333;
        }

        input[type="text"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        button[type="submit"] {
            background-color: #4CAF50;
            color: #fff;
            border: none;
margin-top: 10px;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
        }

        #statusMessage {
            text-align: center;
            margin-top: 20px;
            font-weight: bold;
            color: #333;
        }
    </style>
</head>

<body>
    <h1>Query Form</h1>
    <form id="messageForm">
        <label for="message">Enter your Query:</label>
        <input type="text" id="message" name="message" required>
        <button type="submit">Submit</button>
    </form>

    <div id="statusMessage"></div>

    <script>
        function submitForm(event) {
            event.preventDefault();

            const messageInput = document.getElementById('message');
            const message = messageInput.value;

            const data = {
                Query: message
            };

            const statusMessage = document.getElementById('statusMessage');
            statusMessage.textContent = 'Query is being fetched...';

            fetch('/executeQuery', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            })
                .then(response => {
                    if (response.ok) {
                        return response.blob(); // Retrieve the response body as a Blob
                    } else {
                        throw new Error('Request failed');
                    }
                })
                .then(blobData => {
                    statusMessage.textContent = 'Query fetched successfully';
                    // Process the blobData (protobuf file) as needed
                    // For example, you can save it or use a protobuf library to work with it
                    console.log('Protobuf file received:', blobData);
                })
                .catch(error => {
                    statusMessage.textContent = 'Failed to fetch query';
                    console.error('Error:', error.message);
                });
        }

        const form = document.getElementById('messageForm');
        form.addEventListener('submit', submitForm);
    </script>
</body>

</html>





33333333333333333333333333333333












<!DOCTYPE html>
<html>

<head>
    <title>Message Form</title>
</head>

<body>
    <h1>Message Form</h1>
    <form id="messageForm">
        <label for="message">Enter your message:</label>
        <input type="text" id="message" name="message" required>
        <button type="submit">Submit</button>
    </form>

    <script>
        function submitForm(event) {
            event.preventDefault();

            const messageInput = document.getElementById('message');
            const message = messageInput.value;

            const data = {
                message: message
            };

            fetch('/your-backend-endpoint', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            })
                .then(response => {
                    if (response.ok) {
                        // Handle the response from the backend if needed
                        console.log('Data sent successfully');
                    } else {
                        throw new Error('Request failed');
                    }
                })
                .catch(error => {
                    console.error('Error:', error.message);
                });
        }

        const form = document.getElementById('messageForm');
        form.addEventListener('submit', submitForm);
    </script>
</body>

</html>











<!DOCTYPE html>
<html>
<head>
  <title>Message Form</title>
</head>
<body>
  <h1>Message Form</h1>
  <form id="messageForm">
    <label for="message">Enter your message:</label>
    <input type="text" id="message" name="message" required>
    <button type="submit">Submit</button>
  </form>

  <script>
    // Function to handle form submission
    function submitForm(event) {
      event.preventDefault(); // Prevent form from being submitted normally

      // Get the message value from the input
      const messageInput = document.getElementById('message');
      const message = messageInput.value;

      // Create an object to hold the message
      const data = {
        message: message
      };

      // Convert the data to JSON
      const jsonData = JSON.stringify(data);

      // Send an HTTP request to the backend
      const xhr = new XMLHttpRequest();
      xhr.open('POST', '/executeQuery', true);
      xhr.setRequestHeader('Content-Type', 'application/json');
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4 && xhr.status === 200) {
          // Handle the response from the backend if needed
          console.log(xhr.responseText);
        }
      };
      xhr.send(jsonData);
    }

    // Attach the submitForm function to the form's submit event
    const form = document.getElementById('messageForm');
    form.addEventListener('submit', submitForm);
  </script>
</body>
</html>






















<!DOCTYPE html>
<html>
  <head>
    <title>Neo4j Query Execution</title>
    <script src="script.js"></script>
  </head>
  <body>
    <h1>Neo4j Query Execution</h1>
    <input type="text" id="queryInput" />
    <button onclick="executeQuery()">Execute Query</button>
    <div id="loadingMessage"></div>
    <div id="graph"></div>
  </body>
</html>




// Function to execute the CQL query and fetch the Protobuf file
function executeQuery() {
  const query = document.getElementById("queryInput").value;

  // Display loading message
  const loadingMessageDiv = document.getElementById("loadingMessage");
  loadingMessageDiv.innerText = "Executing query...";

  fetch("/query", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(query),
  })
    .then((response) => {
      if (!response.ok) {
        throw new Error("Error executing query");
      }
      return response.blob(); // Get the response as a Blob
    })
    .then((blob) => {
      // Create a new file object from the Blob
      const file = new File([blob], "graphData.pb", {
        type: "application/octet-stream",
      });

      // Use the file to fetch the WebAssembly file and visualize the graph
      fetchGraphVisualization(file);
    })
    .catch((error) => {
      console.error("Error executing query:", error);
      loadingMessageDiv.innerText = "Error executing query";
    });
}

// Function to fetch the WebAssembly file and visualize the graph
function fetchGraphVisualization(protobufFile) {
  // Fetch the WebAssembly file
  fetch("/wasm/graphVisualization.wasm")
    .then((response) => {
      if (!response.ok) {
        throw new Error("Error fetching WebAssembly file");
      }
      return response.arrayBuffer();
    })
    .then((wasmBuffer) => {
      // Process the Protobuf file and the WebAssembly file to visualize the graph
      processGraphData(protobufFile, wasmBuffer);
    })
    .catch((error) => {
      console.error("Error fetching WebAssembly file:", error);
      document.getElementById("loadingMessage").innerText =
        "Error fetching WebAssembly file";
    });
}

// Function to process the Protobuf file and visualize the graph
function processGraphData(protobufFile, wasmBuffer) {
  // Convert the Protobuf file to an ArrayBuffer
  const reader = new FileReader();
  reader.onload = function () {
    const protobufData = reader.result;

    // Call the WebAssembly function to render the graph
    const wasmInstance = new WebAssembly.Instance(wasmBuffer);
    wasmInstance.exports.renderGraph(protobufData);
  };
  reader.readAsArrayBuffer(protobufFile);
}





/* Example styles */
body {
  font-family: Arial, sans-serif;
}

h1 {
  color: #333;
}

input[type="text"] {
  width: 300px;
  padding: 5px;
  margin-right: 10px;
}

button {
  padding: 5px 10px;
  background-color: #007bff;
  color: #fff;
  border: none;
  cursor: pointer;
}

#loadingMessage {
  margin-top: 10px;
}





<script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>










1.Setting up Neo4j Database: 
		First, we need to install and set up Neo4j, which is a graph database. We can download Neo4j Community Edition from their official website and follow the installation instructions.

    2.Creating the Dummy Database: 
		Once Neo4j is installed, we can create a dummy database by importing sample data or manually adding nodes and relationships. This will provide us with a dataset to work with during development.

    3.Java and Spring Backend: 
		In the backend, we will use Java and the Spring Framework to create a RESTful API that interacts with the Neo4j database. The backend will handle incoming requests, execute Cypher Query Language (CQL) queries against the Neo4j database, and return the query results.

    4.UI Frontend: 
		On the frontend, we will create a user interface using HTML, CSS, and JavaScript. The UI will consist of a textbox where users can enter CQL queries and a button to submit the query.

    5.Query Execution: 
		When the user submits a query from the frontend, the UI will send an HTTP request to the backend API, passing the entered CQL query as a parameter. The backend API will receive the query, execute it against the Neo4j database, and retrieve the results.

    6.Protobuf: 
		Instead of directly sending the query results back to the frontend, the backend will serialize the query results into a Protobuf (Protocol Buffers) message. Protobuf is a language-agnostic binary serialization format that allows for efficient data transfer between systems.

    7.UI Message Display:
		 While the backend is executing the query and generating the Protobuf message, the UI should display a message indicating that the query is being executed. This will provide feedback to the user and prevent them from submitting multiple queries simultaneously.

    8.Receiving Protobuf and Fetching Web Assembly: 
		Once the UI receives the Protobuf message from the backend, it will parse and process it. The Protobuf message will contain information about the nodes and relationships in the graph. The UI will then use this information to fetch a WebAssembly file.

    9.WebAssembly and Web Workers: 
		WebAssembly (WASM) is a binary instruction format that allows running high-performance code on the web. In this project, we will use a WebAssembly file that contains the logic to render the graph visualization. To prevent blocking the UI thread, we will use web workers, which are background JavaScript threads, to execute the WebAssembly code and generate the graph visualization.

    10.Graph Visualization with vis.js: 
		The UI, using the WebAssembly file and web workers, will create a graph visualization using the vis.js library. vis.js is a JavaScript library that provides powerful tools for rendering interactive network graphs. The UI will utilize the data from the Protobuf message to populate the graph and display it on the frontend.


------------------------------------------------------------------------------------------------------------------------------------------------------------------

To summarize the workflow:

    	1.User enters a CQL query in the UI.
    
	2.UI sends the query to the backend API.
    	
	3.Backend executes the query and generates a Protobuf message.
    
	4.UI displays a "query is being executed" message.
    
	5.Backend sends the Protobuf message to the UI.
    	
	6.UI parses the Protobuf message and fetches the WebAssembly file.
    
	7.UI uses web workers to execute the WebAssembly code.
    
	8.UI utilizes vis.js to create the graph visualization based on the Protobuf data.
    
	9.UI displays the graph visualization to the user.

-------------------------------------------------------------------------------------------------------------------------------------------------------------


    Backend: 
		we have a Neo4j database and a backend server implemented in Java and Spring. The backend server receives CQL queries from the frontend.

    Backend Processing:
		The backend server processes the CQL query and retrieves the necessary data from the Neo4j database. It then converts the data into Protobuf format.

    Backend Response: 
		The backend server sends the Protobuf data as a response to the frontend.

    Frontend: 
		The frontend, implemented in HTML, JavaScript, and CSS, consists of an interface with a text box for entering CQL queries and a button to execute the query.

    Execute Query: 
		When the user clicks the "Execute Query" button, the frontend sends an HTTP request to the backend server with the CQL query.

    Backend Processing: 
		The backend server receives the CQL query, executes it on the Neo4j database, and converts the retrieved data into Protobuf format.

    Backend Response: 
		The backend server sends the Protobuf data back to the frontend as the response to the HTTP request.

    Frontend Processing: 
		The frontend receives the Protobuf data from the backend response.

    WebAssembly Processing: 
		The frontend uses a WebAssembly file to process the Protobuf data and generate the graph data in the format expected by Vis.js.

    Visualization: 
		The frontend provides the generated graph data to Vis.js, which renders the graph on the user interface using the HTML and CSS provided.

		So, the WebAssembly file is responsible for processing the Protobuf data received from the backend and converting it into a format that can be visualized by Vis.js. The generated graph data, in the expected format, is then passed to Vis.js for visualization on the frontend.












---------------------------------------







// Create students
CREATE (:Student {name: 'Alice', college: 'College A', place: 'Place 1'})
CREATE (:Student {name: 'Bob', college: 'College B', place: 'Place 2'})
CREATE (:Student {name: 'Carol', college: 'College A', place: 'Place 1'})
CREATE (:Student {name: 'Dave', college: 'College C', place: 'Place 1'})
CREATE (:Student {name: 'Eve', college: 'College D', place: 'Place 3'})
CREATE (:Student {name: 'Frank', college: 'College E', place: 'Place 2'})
CREATE (:Student {name: 'Grace', college: 'College F', place: 'Place 2'})
CREATE (:Student {name: 'Henry', college: 'College G', place: 'Place 3'})
CREATE (:Student {name: 'Ivy', college: 'College A', place: 'Place 1'})
CREATE (:Student {name: 'Jack', college: 'College B', place: 'Place 2'})
CREATE (:Student {name: 'Kelly', college: 'College H', place: 'Place 3'})

// Create company
CREATE (:Company {name: 'XYZ Company', place: 'Place 1'})

// Create relationships
MATCH (s:Student {name: 'Alice'}), (c:Company {place: 'Place 1'})
CREATE (s)-[:INTERNSHIP_AT]->(c)

MATCH (s:Student {name: 'Carol'}), (c:Company {place: 'Place 1'})
CREATE (s)-[:INTERNSHIP_AT]->(c)

MATCH (s:Student {name: 'Dave'}), (c:Company {place: 'Place 1'})
CREATE (s)-[:INTERNSHIP_AT]->(c)

MATCH (s:Student {name: 'Ivy'}), (c:Company {place: 'Place 1'})
CREATE (s)-[:INTERNSHIP_AT]->(c)

MATCH (s:Student {name: 'Bob'}), (c:Company {place: 'Place 2'})
CREATE (s)-[:INTERNSHIP_AT]->(c)

MATCH (s:Student {name: 'Frank'}), (c:Company {place: 'Place 2'})
CREATE (s)-[:INTERNSHIP_AT]->(c)

MATCH (s:Student {name: 'Grace'}), (c:Company {place: 'Place 2'})
CREATE (s)-[:INTERNSHIP_AT]->(c)

MATCH (s:Student {name: 'Eve'}), (c:Company {place: 'Place 3'})
CREATE (s)-[:INTERNSHIP_AT]->(c)

MATCH (s:Student {name: 'Henry'}), (c:Company {place: 'Place 3'})
CREATE (s)-[:INTERNSHIP_AT]->(c)

MATCH (s:Student {name: 'Kelly'}), (c:Company {place: 'Place 3'})
CREATE (s)-[:INTERNSHIP_AT]->(c)



<!DOCTYPE html>
<html>
<head>
  <title>Neo4j Visualization with Vis.js</title>
  <style type="text/css">
    #visualization {
      height: 600px;
      width: 100%;
    }
  </style>
</head>
<body>
  <div id="visualization"></div>
  <script src="https://unpkg.com/vis-network@10.8.1/dist/vis-network.min.js"></script>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="your_script.js"></script>
</body>
</html>






// Create a new Vis.js DataSet for nodes and edges
var nodes = new vis.DataSet();
var edges = new vis.DataSet();

// Connect to Neo4j and retrieve data
var driver = neo4j.driver('bolt://localhost', neo4j.auth.basic('username', 'password'));
var session = driver.session();
session.run('MATCH (n)-[r]->(m) RETURN n, r, m')
  .then(function(result) {
    result.records.forEach(function(record) {
      // Create a Vis.js node object from Neo4j node data
      var neo4jNode = record.get('n');
      var visNode = {
        id: neo4jNode.identity.toString(),
        label: neo4jNode.labels[0],
        title: JSON.stringify(neo4jNode.properties),
      };
      nodes.add(visNode);

      // Create a Vis.js edge object from Neo4j relationship data
      var neo4jRelationship = record.get('r');
      var visEdge = {
        id: neo4jRelationship.identity.toString(),
        from: neo4jRelationship.start.toString(),
        to: neo4jRelationship.end.toString(),
        label: neo4jRelationship.type,
        title: JSON.stringify(neo4jRelationship.properties),
      };
      edges.add(visEdge);
    });

    // Create a network using the container and data
    var container = document.getElementById('visualization');
    var data = { nodes: nodes, edges: edges };
    var options = {}; // Customize the visualization options as needed
    var network = new vis.Network(container, data, options);
  })
  .catch(function(error) {
    console.error('Error connecting to Neo4j:', error);
  })
  .finally(function() {
    session.close();
    driver.close();
  });








<!DOCTYPE html>
<html>
<head>
  <title>Neo4j Visualization with vis.js</title>
  <style type="text/css">
    #visualization {
      width: 100%;
      height: 500px;
    }
  </style>
  <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
</head>
<body>
  <div id="visualization"></div>

  <script type="text/javascript">
    // Create a new network instance
    var container = document.getElementById("visualization");
    var data = {
      nodes: [],
      edges: []
    };

    // Neo4j connection configuration
    var config = {
      container: container,
      serverUrl: "bolt://localhost:7687",
      serverUser: "neo4j",
      serverPassword: "your_password",
      labels: {
        "Student": {
          caption: "name"
        }
      },
      relationships: {
        "INTERNSHIP_AT": {
          thickness: "weight"
        }
      }
    };

    // Connect to Neo4j and retrieve data
    var driver = neo4j.v1.driver(config.serverUrl, neo4j.v1.auth.basic(config.serverUser, config.serverPassword));
    var session = driver.session();
    var cypherQuery = 'MATCH (n) RETURN n';
    session.run(cypherQuery)
      .then(function(result) {
        result.records.forEach(function(record) {
          var node = record.get("n");
          var nodeId = node.identity.toString();
          var nodeLabel = node.labels[0];
          var nodeProps = node.properties;
          data.nodes.push({ id: nodeId, label: nodeLabel, title: nodeProps.name });

          var relationships = node.relationships;
          relationships.forEach(function(relationship) {
            var relationshipId = relationship.identity.toString();
            var relationshipType = relationship.type;
            var relationshipProps = relationship.properties;
            var sourceNodeId = relationship.start.toString();
            var targetNodeId = relationship.end.toString();
            data.edges.push({ id: relationshipId, from: sourceNodeId, to: targetNodeId, label: relationshipType, title: relationshipProps.weight });
          });
        });

        // Create the network visualization
        var options = {};
        var network = new vis.Network(container, data, options);
      })
      .catch(function(error) {
        console.error("Error retrieving data from Neo4j: ", error);
      })
      .finally(function() {
        session.close();
        driver.close();
      });
  </script>
</body>
</html>








CREATE (:Student {name: "John Doe", college: "ABC University", place: "City A"})
CREATE (:Student {name: "Jane Smith", college: "XYZ College", place: "City B"})
CREATE (:Student {name: "David Johnson", college: "PQR Institute", place: "City C"})
CREATE (:Student {name: "Sarah Brown", college: "LMN University", place: "City D"})
CREATE (:Student {name: "Michael Wilson", college: "EFG College", place: "City E"})
CREATE (:Student {name: "Emily Davis", college: "UVW Institute", place: "City F"})
CREATE (:Student {name: "Daniel Taylor", college: "HIJ University", place: "City G"})
CREATE (:Student {name: "Olivia Lee", college: "KLM College", place: "City H"})
CREATE (:Student {name: "Matthew Clark", college: "NOP Institute", place: "City I"})
CREATE (:Student {name: "Sophia Lewis", college: "QRS University", place: "City J"})
CREATE (:Student {name: "James Martinez", college: "TUV College", place: "City K"})
CREATE (:Student {name: "Ava Hall", college: "XYZ Institute", place: "City L"})
CREATE (:Student {name: "William Mitchell", college: "ABC University", place: "City M"})
CREATE (:Student {name: "Isabella Scott", college: "PQR College", place: "City N"})
CREATE (:Student {name: "Daniel Thompson", college: "LMN Institute", place: "City O"})
CREATE (:Student {name: "Mia Walker", college: "EFG University", place: "City P"})
CREATE (:Student {name: "Alexander Adams", college: "UVW College", place: "City Q"})
CREATE (:Student {name: "Sofia Hill", college: "HIJ Institute", place: "City R"})
CREATE (:Student {name: "Ethan Turner", college: "KLM University", place: "City S"})
CREATE (:Student {name: "Charlotte Baker", college: "NOP College", place: "City T"})

MATCH (s1:Student),(s2:Student)
WHERE s1 <> s2
WITH s1, s2
LIMIT 10
CREATE (s1)-[:INTERNSHIP_AT]->(s2)









CREATE (:Student {name: "John Doe", college: "ABC University", place: "City A"})
CREATE (:Student {name: "Jane Smith", college: "XYZ College", place: "City B"})
CREATE (:Student {name: "David Johnson", college: "PQR Institute", place: "City C"})
CREATE (:Student {name: "Sarah Brown", college: "LMN University", place: "City D"})
CREATE (:Student {name: "Michael Wilson", college: "EFG College", place: "City E"})
CREATE (:Student {name: "Emily Davis", college: "UVW Institute", place: "City F"})
CREATE (:Student {name: "Daniel Taylor", college: "HIJ University", place: "City G"})
CREATE (:Student {name: "Olivia Lee", college: "KLM College", place: "City H"})
CREATE (:Student {name: "Matthew Clark", college: "NOP Institute", place: "City I"})
CREATE (:Student {name: "Sophia Lewis", college: "QRS University", place: "City J"})
CREATE (:Student {name: "James Martinez", college: "TUV College", place: "City K"})
CREATE (:Student {name: "Ava Hall", college: "XYZ Institute", place: "City L"})
CREATE (:Student {name: "William Mitchell", college: "ABC University", place: "City M"})
CREATE (:Student {name: "Isabella Scott", college: "PQR College", place: "City N"})
CREATE (:Student {name: "Daniel Thompson", college: "LMN Institute", place: "City O"})
CREATE (:Student {name: "Mia Walker", college: "EFG University", place: "City P"})
CREATE (:Student {name: "Alexander Adams", college: "UVW College", place: "City Q"})
CREATE (:Student {name: "Sofia Hill", college: "HIJ Institute", place: "City R"})
CREATE (:Student {name: "Ethan Turner", college: "KLM University", place: "City S"})
CREATE (:Student {name: "Charlotte Baker", college: "NOP College", place: "City T"})

MATCH (s1:Student {name: "John Doe"}), (s2:Student {name: "Jane Smith"})
CREATE (s1)-[:INTERNSHIP_AT]->(s2)

MATCH (s1:Student {name: "John Doe"}), (s3:Student {name: "David Johnson"})
CREATE (s1)-[:INTERNSHIP_AT]->(s3)

MATCH (s1:Student {name: "John Doe"}), (s4:Student {name: "Sarah Brown"})
CREATE (s1)-[:INTERNSHIP_AT]->(s4)

MATCH (s1:Student {name: "John Doe"}), (s5:Student {name: "Michael Wilson"})
CREATE (s1)-[:INTERNSHIP_AT]->(s5)

MATCH (s2:Student {name: "Jane Smith"}), (s6:Student {name: "Emily Davis"})
CREATE (s2)-[:INTERNSHIP_AT]->(s6)

MATCH (s2:Student {name: "Jane Smith"}), (s7:Student {name: "Daniel Taylor"})
CREATE (s2)-[:INTERNSHIP_AT]->(s7)

MATCH (s2:Student {name: "Jane Smith"}), (s8:Student {name: "Olivia Lee"})
CREATE (s2






MATCH (a:Person {name: "Alice"}), (b:Person {name: "Bob"})
CREATE (a)-[:FRIEND]->(b)

MATCH (a:Person {name: "Alice"}), (c:Person {name: "Charlie"})
CREATE (a)-[:FRIEND]->(c)

MATCH (a:Person {name: "Bob"}), (d:Person {name: "David"})
CREATE (a)-[:FRIEND]->(d)

MATCH (b:Person {name: "Bob"}), (e:Person {name: "Eve"})
CREATE (b)-[:FRIEND]->(e)

MATCH (c:Person {name: "Charlie"}), (f:Person {name: "Frank"})
CREATE (c)-[:FRIEND]->(f)

MATCH (d:Person {name: "David"}), (g:Person {name: "Grace"})
CREATE (d)-[:FRIEND]->(g)

MATCH (e:Person {name: "Eve"}), (h:Person {name: "Henry"})
CREATE (e)-[:FRIEND]->(h)

MATCH (f:Person {name: "Frank"}), (i:Person {name: "Ivy"})
CREATE (f)-[:FRIEND]->(i)

MATCH (g:Person {name: "Grace"}), (j:Person {name: "Jack"})
CREATE (g)-[:FRIEND]->(j)

MATCH (h:Person {name: "Henry"}), (k:Person {name: "Karen"})
CREATE (h)-[:FRIEND]->(k)

MATCH (i:Person {name: "Ivy"}), (l:Person {name: "Liam"})
CREATE (i)-[:FRIEND]->(l)

MATCH (j:Person {name: "Jack"}), (m:Person {name: "Mia"})
CREATE (j)-[:FRIEND]->(m)

MATCH (k:Person {name: "Karen"}), (n:Person {name: "Nathan"})
CREATE (k)-[:FRIEND]->(n)

MATCH (l:Person {name: "Liam"}), (o:Person {name: "Olivia"})
CREATE (l)-[:FRIEND]->(o)

MATCH (m:Person {name: "Mia"}), (p:Person {name: "Nathan"})
CREATE (m)-[:FRIEND]->(p)


11






MATCH (a:Person {name: "Alice"}), (b:Person {name: "Bob"})
CREATE (a)-[:FRIEND]->(b),
       (a)-[:COLLEAGUE]->(b),
       (a)-[:NEIGHBOR]->(b)

MATCH (a:Person {name: "Alice"}), (c:Person {name: "Charlie"})
CREATE (a)-[:FRIEND]->(c),
       (a)-[:SIBLING]->(c),
       (a)-[:CO-WORKER]->(c)

MATCH (a:Person {name: "Bob"}), (d:Person {name: "David"})
CREATE (a)-[:FRIEND]->(d),
       (a)-[:COLLEAGUE]->(d),
       (a)-[:CLASSMATE]->(d)

MATCH (b:Person {name: "Bob"}), (e:Person {name: "Eve"})
CREATE (b)-[:FRIEND]->(e),
       (b)-[:NEIGHBOR]->(e),
       (b)-[:CO-WORKER]->(e)

MATCH (c:Person {name: "Charlie"}), (f:Person {name: "Frank"})
CREATE (c)-[:FRIEND]->(f),
       (c)-[:SIBLING]->(f),
       (c)-[:COLLEAGUE]->(f)

MATCH (d:Person {name: "David"}), (g:Person {name: "Grace"})
CREATE (d)-[:FRIEND]->(g),
       (d)-[:CO-WORKER]->(g),
       (d)-[:CLASSMATE]->(g)

MATCH (e:Person {name: "Eve"}), (h:Person {name: "Henry"})
CREATE (e)-[:FRIEND]->(h),
       (e)-[:NEIGHBOR]->(h),
       (e)-[:SIBLING]->(h)

MATCH (f:Person {name: "Frank"}), (i:Person {name: "Ivy"})
CREATE (f)-[:FRIEND]->(i),
       (f)-[:COLLEAGUE]->(i),
       (f)-[:NEIGHBOR]->(i)

MATCH (g:Person {name: "Grace"}), (j:Person {name: "Jack"})
CREATE (g)-[:FRIEND]->(j),
       (g)-[:CLASSMATE]->(j),
       (g)-[:CO-WORKER]->(j)

MATCH (h:Person {name: "Henry"}), (k:Person {name: "Karen"})
CREATE (h)-[:FRIEND]->(k),
       (h)-[:NEIGHBOR]->(k),
       (h)-[:COLLEAGUE]->(k)

MATCH (i:Person {name: "Ivy"}), (l:Person {name: "Liam"})
CREATE (i)-[:FRIEND]->(l),
       (i)-[:SIBLING]->(l),
       (i)-[:CLASSMATE]->(l)

MATCH (j:Person {name: "Jack"}), (m:Person {name: "Mia"})
CREATE (j)-[:FRIEND]->(m),
       (j)-[:CO-WORKER]->(m),
       (j)-[:NEIGHBOR]->(m)

MATCH (k:Person {name: "Karen"}), (n:Person {name: "Nathan"})
CREATE (k)-[:FRIEND]->(n),
       (k)-[:COLLEAGUE]->(n),
       (k)-[:SIBLING]->(n)

MATCH (l:Person {name: "Liam"}), (o:Person {name: "Olivia"})
CREATE (l)-[:FRIEND]->(o),
       (l)-[:NEIGHBOR]->(o),
       (l)-[:CLASSMATE]->(o)

MATCH (m:Person {name: "Mia"}), (p:Person {name: "Nathan"})
CREATE (m)-[:FRIEND]->(p),
       (m)-[:CO-WORKER]->(p),
       (m)-[:SIBLING]->(p)













<!DOCTYPE html>
<html>
<head>
  <title>Neo4j Visualization with Vis.js</title>
  <style type="text/css">
    #visualization {
      width: 800px;
      height: 600px;
      border: 1px solid lightgray;
    }
  </style>
</head>
<body>
  <div id="visualization"></div>
  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <script>
    // Neo4j data
    var nodes = [
      { id: 1, label: 'Alice' },
      { id: 2, label: 'Bob' },
      { id: 3, label: 'Charlie' },
      { id: 4, label: 'David' },
      { id: 5, label: 'Eve' },
      { id: 6, label: 'Frank' },
      { id: 7, label: 'Grace' },
      { id: 8, label: 'Henry' },
      { id: 9, label: 'Ivy' },
      { id: 10, label: 'Jack' },
      { id: 11, label: 'Karen' },
      { id: 12, label: 'Liam' },
      { id: 13, label: 'Mia' },
      { id: 14, label: 'Nathan' },
      { id: 15, label: 'Olivia' }
    ];

    var edges = [
      { from: 1, to: 2, label: 'FRIEND' },
      { from: 1, to: 3, label: 'FRIEND' },
      { from: 1, to: 4, label: 'FRIEND' },
      { from: 2, to: 3, label: 'FRIEND' },
      { from: 2, to: 4, label: 'FRIEND' },
      { from: 2, to: 5, label: 'FRIEND' },
      { from: 3, to: 4, label: 'FRIEND' },
      { from: 3, to: 6, label: 'FRIEND' },
      { from: 3, to: 7, label: 'FRIEND' },
      { from: 4, to: 5, label: 'FRIEND' },
      { from: 4, to: 6, label: 'FRIEND' },
      { from: 4, to: 7, label: 'FRIEND' },
      { from: 5, to: 6, label: 'FRIEND' },
      { from: 5, to: 7, label: 'FRIEND' },
      { from: 5, to: 8, label: 'FRIEND' },
      { from: 6, to: 7, label: 'FRIEND' },
      { from: 6, to: 8, label: 'FRIEND' },
      { from: 6, to: 9, label: 'FRIEND' },
      { from: 7, to: 8, label: 'FRIEND' },
      { from: 7, to: 9, label: 'FRIEND' },
      { from: 7, to: 10, label: 'FRIEND' },
      { from: 8, to: 9, label: 'FRIEND' },
      { from: 8, to: 10, label: 'FRIEND' },
      { from: 8, to: 11, label: 'FRIEND' },
      { from: 9, to: 10, label: 'FRIEND' },
      { from: 9, to: 11, label: 'FRIEND' },
      { from: 9, to: 12, label: 'FRIEND' },
      { from: 10, to: 11, label: 'FRIEND' },
      { from: 10, to: 12, label: 'FRIEND' },
      { from: 10, to: 13, label: 'FRIEND' },
      { from: 11, to: 12, label: 'FRIEND' },
      { from: 11, to: 13, label: 'FRIEND' },
      { from: 11, to: 14, label: 'FRIEND' },
      { from: 12, to: 13, label: 'FRIEND' },
      { from: 12, to: 14, label: 'FRIEND' },
      { from: 12, to: 15, label: 'FRIEND' },
      { from: 13, to: 14, label: 'FRIEND' },
      { from: 13, to: 15, label: 'FRIEND' },
      { from: 14, to: 15, label: 'FRIEND' }
    ];

    var data = {
      nodes: nodes,
      edges: edges
    };

    // Visualization options
    var options = {
      nodes: {
        shape: 'dot',
        size: 30,
        font: {
          size: 14,
          color: '#ffffff'
        },
        borderWidth: 2
      },
      edges: {
        width: 2
      }
    };

    // Create a network
    var container = document.getElementById('visualization');
    var network = new vis.Network(container, data, options);
  </script>
</body>
</html>










<!DOCTYPE html>
<html>
<head>
  <title>Neo4j Visualization with Vis.js</title>
  <style type="text/css">
    #visualization {
      width: 800px;
      height: 600px;
      border: 1px solid lightgray;
    }
  </style>
</head>
<body>
  <div id="visualization"></div>
  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <script src="data.js"></script>
  <script src="main.js"></script>
</body>
</html>




var nodes = [
  { id: 1, label: 'Alice' },
  { id: 2, label: 'Bob' },
  { id: 3, label: 'Charlie' },
  { id: 4, label: 'David' },
  { id: 5, label: 'Eve' },
  { id: 6, label: 'Frank' },
  { id: 7, label: 'Grace' },
  { id: 8, label: 'Henry' },
  { id: 9, label: 'Ivy' },
  { id: 10, label: 'Jack' },
  { id: 11, label: 'Karen' },
  { id: 12, label: 'Liam' },
  { id: 13, label: 'Mia' },
  { id: 14, label: 'Nathan' },
  { id: 15, label: 'Olivia' }
];

var edges = [
  { from: 1, to: 2, label: 'FRIEND' },
  { from: 1, to: 2, label: 'COLLEAGUE' },
  { from: 1, to: 2, label: 'NEIGHBOR' },
  // Add more relationships here...
];

var data = {
  nodes: nodes,
  edges: edges
};




var container = document.getElementById('visualization');
var options = {
  nodes: {
    shape: 'dot',
    size: 30,
    font: {
      size: 14,
      color: '#ffffff'
    },
    borderWidth: 2
  },
  edges: {
    width: 2
  }
};
var network = new vis.Network(container, data, options);







CREATE (:Person {name: "Alice", age: 25})
CREATE (:Person {name: "Bob", age: 30})
CREATE (:Person {name: "Charlie", age: 35})
CREATE (:Person {name: "David", age: 40})
CREATE (:Person {name: "Eve", age: 22})
CREATE (:Person {name: "Frank", age: 28})
CREATE (:Person {name: "Grace", age: 33})
CREATE (:Person {name: "Henry", age: 29})
CREATE (:Person {name: "Ivy", age: 37})
CREATE (:Person {name: "Jack", age: 31})
CREATE (:Person {name: "Karen", age: 26})
CREATE (:Person {name: "Liam", age: 27})
CREATE (:Person {name: "Mia", age: 24})
CREATE (:Person {name: "Nathan", age: 32})
CREATE (:Person {name: "Olivia", age: 36})




133456788








const express = require('express');
const neo4j = require('neo4j-driver');

// Neo4j configuration
const neo4jUri = 'bolt://localhost:7687'; // Replace with your Neo4j URI
const neo4jUser = 'neo4j'; // Replace with your Neo4j username
const neo4jPassword = 'password'; // Replace with your Neo4j password

// Create a Neo4j driver instance
const driver = neo4j.driver(neo4jUri, neo4j.auth.basic(neo4jUser, neo4jPassword));

// Create Express.js app
const app = express();

// REST API endpoint to retrieve Neo4j data
app.get('/api/graph', async (req, res) => {
  const session = driver.session();

  try {
    const result = await session.run('MATCH (n) RETURN n');

    const nodes = result.records.map(record => {
      const node = record.get('n');
      return {
        id: node.identity.toString(),
        label: node.properties.name
      };
    });

    const edges = [];

    res.json({ nodes, edges });
  } catch (error) {
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    session.close();
  }
});

// Start the server
app.listen(3000, () => {
  console.log('Server started on port 3000');
});






<!DOCTYPE html>
<html>
<head>
  <title>Neo4j Visualization with Vis.js</title>
  <style type="text/css">
    #visualization {
      width: 800px;
      height: 600px;
      border: 1px solid lightgray;
    }
  </style>
</head>
<body>
  <div id="visualization"></div>
  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <script>
    // Retrieve data from the server
    fetch('/api/graph')
      .then(response => response.json())
      .then(data => {
        const container = document.getElementById('visualization');
        const options = {
          nodes: {
            shape: 'dot',
            size: 30,
            font: {
              size: 14,
              color: '#ffffff'
            },
            borderWidth: 2
          },
          edges: {
            width: 2
          }
        };
        const network = new vis.Network(container, data, options);
      })
      .catch(error => {
        console.error('An error occurred:', error);
      });
  </script>
</body>
</html>












const express = require('express');
const neo4j = require('neo4j-driver');

// Neo4j configuration
const neo4jUri = 'bolt://localhost:7687'; // Replace with your Neo4j URI
const neo4jUser = 'neo4j'; // Replace with your Neo4j username
const neo4jPassword = 'password'; // Replace with your Neo4j password

// Create a Neo4j driver instance
const driver = neo4j.driver(neo4jUri, neo4j.auth.basic(neo4jUser, neo4jPassword));

// Create Express.js app
const app = express();

// REST API endpoint to retrieve Neo4j data
app.get('/api/graph', async (req, res) => {
  const session = driver.session();

  try {
    const result = await session.run('MATCH (n)-[r]->(m) RETURN n, r, m');

    const nodes = new Set();
    const edges = [];

    result.records.forEach(record => {
      const sourceNode = record.get('n');
      const relationship = record.get('r');
      const targetNode = record.get('m');

      nodes.add(sourceNode);
      nodes.add(targetNode);

      edges.push({
        from: sourceNode.identity.toString(),
        to: targetNode.identity.toString(),
        label: relationship.type
      });
    });

    const nodeArray = Array.from(nodes).map(node => ({
      id: node.identity.toString(),
      label: node.properties.name
    }));

    res.json({ nodes: nodeArray, edges });
  } catch (error) {
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    await session.close();
  }
});

// Start the server
app.listen(3000, () => {
  console.log('Server started on port 3000');
});




111111111111111




<!DOCTYPE html>
<html>
<head>
  <title>Neo4j Visualization with Vis.js</title>
  <style type="text/css">
    #visualization {
      width: 800px;
      height: 600px;
      border: 1px solid lightgray;
    }
  </style>
</head>
<body>
  <div id="visualization"></div>
  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <script>
    // Retrieve data from the server
    fetch('/api/graph')
      .then(response => response.json())
      .then(data => {
        // Create nodes array
        const nodes = data.nodes.map(node => ({
          id: node.id,
          label: node.label
        }));

        // Create edges array
        const edges = data.edges.map(edge => ({
          from: edge.from,
          to: edge.to,
          label: edge.label
        }));

        // Create data object for Vis.js
        const visData = {
          nodes: new vis.DataSet(nodes),
          edges: new vis.DataSet(edges)
        };

        // Create options for Vis.js
        const options = {
          nodes: {
            shape: 'dot',
            size: 30,
            font: {
              size: 14,
              color: '#ffffff'
            },
            borderWidth: 2
          },
          edges: {
            width: 2
          }
        };

        // Create a network visualization
        const container = document.getElementById('visualization');
        const network = new vis.Network(container, visData, options);
      })
      .catch(error => {
        console.error('An error occurred:', error);
      });
  </script>
</body>
</html>



.......

const express = require('express');
const neo4j = require('neo4j-driver');
const vis = require('vis-network');

// Neo4j configuration
const neo4jUri = 'bolt://localhost:7687'; // Replace with your Neo4j URI
const neo4jUser = 'neo4j'; // Replace with your Neo4j username
const neo4jPassword = 'password'; // Replace with your Neo4j password

// Create a Neo4j driver instance
const driver = neo4j.driver(neo4jUri, neo4j.auth.basic(neo4jUser, neo4jPassword));

// Create Express.js app
const app = express();

// Set up static files directory (if needed)
app.use(express.static('public'));

// REST API endpoint to retrieve Neo4j data
app.get('/api/graph', async (req, res) => {
  const session = driver.session();

  try {
    const result = await session.run('MATCH (n)-[r]->(m) RETURN n, r, m');

    const nodes = new vis.DataSet();
    const edges = new vis.DataSet();

    result.records.forEach(record => {
      const sourceNode = record.get('n');
      const relationship = record.get('r');
      const targetNode = record.get('m');

      nodes.add({
        id: sourceNode.identity.toString(),
        label: sourceNode.properties.name
      });

      nodes.add({
        id: targetNode.identity.toString(),
        label: targetNode.properties.name
      });

      edges.add({
        id: relationship.identity.toString(),
        from: sourceNode.identity.toString(),
        to: targetNode.identity.toString(),
        label: relationship.type
      });
    });

    const data = {
      nodes: nodes,
      edges: edges
    };

    res.json(data);
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    await session.close();
  }
});

// Start the server
app.listen(3000, () => {
  console.log('Server started on port 3000');
});



9999999o



from pyvis.network import Network
from neo4j import GraphDatabase

# Neo4j configuration
neo4j_uri = "bolt://localhost:7687"  # Replace with your Neo4j URI
neo4j_user = "neo4j"  # Replace with your Neo4j username
neo4j_password = "password"  # Replace with your Neo4j password

# Connect to Neo4j database
driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
session = driver.session()

# Retrieve graph data from Neo4j
query = "MATCH (n)-[r]->(m) RETURN n, r, m"
result = session.run(query)

# Create a PyVis network
net = Network(height="600px", width="800px")

# Add nodes and edges to the network
for record in result:
    source_node = record["n"]
    relationship = record["r"]
    target_node = record["m"]

    net.add_node(source_node.id, label=source_node.get("name"))
    net.add_node(target_node.id, label=target_node.get("name"))
    net.add_edge(source_node.id, target_node.id, label=relationship.type)

# Visualize the graph
net.show("graph.html")




1
1
1



// Neo4j connection details
const neo4j = require('neo4j-driver');
const driver = neo4j.driver('bolt://localhost:7687', neo4j.auth.basic('your_username', 'your_password'));

// Neo4j query to fetch nodes
const neo4jQuery = `
MATCH (n)
RETURN n
`;

// Create an empty array to store the nodes
const nodes = [];

// Execute the query and fetch the nodes
const session = driver.session();
session
  .run(neo4jQuery)
  .subscribe({
    onNext: (record) => {
      const node = record.get('n');
      
      // Add nodes
      nodes.push({
        id: node.identity.toString(),
        label: node.labels[0],
        title: JSON.stringify(node.properties)
      });
    },
    onCompleted: () => {
      session.close();

      // Create a Vis.js data object
      const data = {
        nodes: nodes,
        edges: []
      };

      // Create a Vis.js network
      const container = document.getElementById('network');
      const options = {};
      const network = new vis.Network(container, data, options);
    },
    onError: (error) => {
      console.error(error);
    }
  });
  
  
  
  
  
  
  
 <!DOCTYPE html>
<html>
<head>
  <title>Neo4j Visualization</title>
  <style>
    #network {
      width: 800px;
      height: 600px;
    }
  </style>
</head>
<body>
  <div id="network"></div>
  <script src="https://cdn.jsdelivr.net/npm/vis-network@9.5.1/dist/vis-network.min.js"></script>
  <script src="https://unpkg.com/neo4j-driver@4.3.1/dist/neo4j-driver.min.js"></script>
  <script src="path/to/your/javascript/file.js"></script>
</body>
</html>
 
